using System;
using System.Collections.Generic;

public class Program
{
	//https://leetcode.com/problems/k-closest-points-to-origin/
	public static void Main()
	{
		//PriorityQueue<int, int> MaxHeap = new PriorityQueue<int, int>(new MaxHeapComparer()); //Max Heap
		PriorityQueue<int, int> MinHeap = new PriorityQueue<int, int>(); //MIN Heap
		int[] arr = {1, 2, 2, 2, 4, 4, 4, 5, 5, 5, 5, 5, 7, 7, 8, 8, 8, 8};
		int k = 1;
		//Map
		Dictionary<int,int> mapper = new Dictionary<int,int>();
		foreach(var ele in arr)
		{
			int count;
			mapper.TryGetValue(ele,out count);
			if(count==0)
			{
				mapper.Add(ele,1);
			}
			else{
				mapper[ele]++;
			}
		}
		
		//Using MaxHeap
		foreach(var item in mapper)
		{
			MinHeap.Enqueue(item.Key,item.Value);
			if(MinHeap.Count > k){MinHeap.Dequeue();}
			Console.WriteLine($"item : {item.Key} && Value : {item.Value}");
		}
		while(MinHeap.TryDequeue(out int element,out int p))
		{
			Console.WriteLine($"element : {element}");
		}
	}

	class MaxHeapComparer : IComparer<int>
	{
		public int Compare(int element1, int element2)
		{
			if (element1 == element2) //If both are fancy (Or both are not fancy, return 0 as they are equal)
			{
				//Console.WriteLine($" 0 : element1 :{element1} && element2 : {element2}");
				return 0;
			}
			else if (element1 > element2) //if element1 is greater than element2 then put element 2 on above element one
			{
				//Console.WriteLine($"-1 : element1 :{element1} && element2 : {element2}");
				return -1;
			}
			else //Otherwise it must be that B is fancy (And A is not), so return 1
			{
				//Console.WriteLine($" 1 : element1 :{element1} && element2 : {element2}");
				return 1;
			}
		}
	}
}
